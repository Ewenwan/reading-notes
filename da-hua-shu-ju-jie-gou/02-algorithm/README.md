# 算法

## 算法定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

## 算法的特性
* **输入输出：** 算法具有零个或多个输入
* **有穷性：** 指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
* **确定性：** 算法的每一个步骤都具有确定的含义，不会出现二义性。
* **可行性：** 算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限的次数完成。

## 算法设计的要求
* **正确性：** 算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。
	1. 	算法程序没有语法错误
	2. 算法程序对于合法的输入能够产生满足要求的输出结果
	3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
	4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。
* **可读性：** 算法设计的另一目的是为了便于阅读、理解和交流。
* **健壮性：** 当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。  
* **时间效率高和存储量低：** 设计算法应该尽量满足时间效率高和存储量低的需求。  

## 算法效率的度量方法
* **事后统计方法：** 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序运行时间进行比较，从而确定算法效率的高低。
* **事前分析估算方法：** 在计算机程序编制前，依据统计方法对算法进行估算。

## 函数的渐进增长
给定两个函数 f(n) 和 g(n), 如果存在一个整数 N，使得对于所有的 n > N, f(n) 总是比 g(n) 大，那么我们说f(n)的增长渐进快于 g(n)。

## 算法的时间复杂度
### 算法时间复杂度的定义
在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模的增大，算法执行时间的增长率和 f(n) 的增长率相同，乘坐算法的渐进时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。

### 推导大O阶方法
1. 用常数 1 取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶

### 常数阶
```c
int sum =0, n=100;
sum = (1+n)*n/2;
printf("%d", sum);
```
1. 算法运行次数函数为 f(n) = 3;
2. 用常数 1 取代运行时间中的所有加法常数，得到 f(n) = 1。
3. 由于没有最高阶项，所以此算法的时间复杂度为 O(1)。

### 线性阶
```c
int i;
for(i=0; i<n; i++) {
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
```
1. 算法运行次数的函数为 f(n) = n;
2. 没有加法常数取代, f(n) = n;
3. 只保留最高阶项，f(n) = n;
4. 最高阶项存在但是1，所以该算法时间复杂度为 O(n)

### 对数阶
```c
int count = 1;
while(count < n) {
	count = count * 2;
	/* 时间复杂度为 O(1) 的程序步骤序列 */
}
```
1. 有多少个 2 相乘后大于 n，则会退出循环，由 2^x = n, 得到算法运行次数函数 f(n) = log<sub>2</sub>n。
2. 没有加法常数取代, f(n) = log<sub>2</sub>n。
3. 至保留最高阶项，f(n) = log<sub>2</sub>n。
4. 最高阶项存在且不是1，去除与这个项相乘的系数，所以该算法时间复杂度为 O(logn)


### 平方阶
```c
int i, j;
for(i=0; i<n; i++) {
	for(j=0; j<n; j++) {
		/* 时间复杂度为 O(1) 的程序步骤序列 */
	}
}
```
1. 算法运行次数函数 f(n) = n^2。
2. 没有常数，f(n) = n^2。
3. 只保留最高阶项，f(n) = n^2。
4. 最高阶项存在但系数为1，所以该算法时间复杂度为 O(n^2)

### 常见的时间复杂度
| 执行次数函数 | 阶 | 非正式术语 |
|:--:|:--:|:--:|
| 12 | O(1) | 常数阶 |
| 2n+3 | O(n) | 线性阶 |
| 3n^2 + 2n +1| O(n^2) | 平方阶 |
| 5log<sub>2</sub>n + 20| O(logn) | 对数阶| 
| 2n + 3nlog<sub>2</sub>n + 19 | O(nlogn) | nlogn 阶| 
| 6n^3 + 2n^2 + 3n + 4 | O(n^3) | 立方阶 |
| 2^n | O(2^n) | 指数阶 |

常用时间复杂度所耗费的时间从小到大依次是：   
**O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(n!) < O(n^n)**

### 最坏情况与平均情况
最坏情况运行时间是一种保证，那就是运行时间不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。

平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

一般没有特殊说明的情况下，时间复杂度都是指最坏时间复杂度。  

### 算法空间复杂度
算法的空间复杂度通过计算算法所需的存储空间时间，算法空间复杂度的计算公式记作：**S(n)=O(f(n))**, 其中 n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。

通常我们都使用 “时间复杂度” 来指运行时间的需求， “空间复杂度” 来指空间徐秀。当不用限定词的使用 “复杂度” 时，通常是指时间复杂度。

### 总结回顾
**算法的定义：** 算法是解决特定问题求解步骤的描述，在计算机中卫指令的有限序列，并且每条指令表示一个或多个操作。  
**算法的特性：** 有穷性、确定性、可行性、输入、输出。  
**算法的设计的要求：** 正确性、可读性、健壮性、高效率和低存储量需求。  
**算法的度量方法：** 事后统计方法(不科学、不准确)，事前分析估算方法。  
**函数的渐进增长：** 给定两个函数 f(n) 和 g(n)，如果存在一个整数 N, 使得对于所有的 n > N, f(n) 总是比 g(n) 大，那么我们说 f(n) 的增长渐进快于 g(n)。  
**推导大 O 阶：**  
  
* 	用常数 1 取代运行时间中的所有加法常数  
*  在修改后的运行次数函数中，只保留最高阶项  
*  如果最高阶项存在且不是1，则去除与这个项相乘的常数。 
 
得到的结果就是大 O 阶  

**常见时间复杂度所耗时间的大小排列：** O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(n!) < O(n^n)



